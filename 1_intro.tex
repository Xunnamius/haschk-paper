\section{Introduction} \label{sec:introduction}

In 2010, through compromising legitimate applications available on trusted
vendor websites, nation-state actors launched the Havex malware, targeting
aviation, defense, pharmaceutical, and other companies in Europe and the United
States~\cite{SCA-HAVEX1, SCA-HAVEX2}. In 2012, attackers compromised an official
phpMyAdmin download mirror hosted by reputable software provider SourceForge.
The backdoored version of the popular database frontend was downloaded by
hundreds of users, potentially allowing attackers to gain access to private
customer data~\cite{SCA-PMA1, SCA-PMA2}. In 2016, attackers broke into the Linux
Mint distribution server and replaced a legitimate Mint ISO with one containing
a backdoor, infecting hundreds of machines with the malware~\cite{SCA-MINT1,
SCA-MINT2}. Over a four day period in 2017, users of the popular HandBrake open
source video transcoder on Mac/OSX were made aware that, along with their
expected video software, they may have also downloaded a trojan that was
uploading their sensitive data to a remote server~\cite{SCA-HB1}. HandBrake
developers recommended users perform checksum validation to determine if their
install was compromised~\cite{SCA-HB2}.

As every internet user is certainly aware, downloading resources over the
internet comes with considerable risk. This risk can be divided into three broad
concerns: response authentication, communication confidentiality, and resource
integrity. Response authentication allows us to determine if a response received
indeed originates from its purported source through,
for instance, the adoption of a Public Key Infrastructure (PKI)
scheme~\cite{PKI}. Communication confidentiality, on the other hand, allows us
to keep the data transacted between two or more parties private except to said
parties through some form of encryption, such as
AES~\cite{AES}. Finally, resource integrity allows us to verify that the data we
are receiving is the data we are expecting to receive.

When it comes to response authentication and communication confidentiality
concerns on the internet, the state of the art in attack mitigation is Transport
Layer Security (TLS) and its Hyper Text Transfer Protocol (HTTP)/PKI based
implementation, HTTPS~\cite{TLS1.2, TLS1, TLS0, HTTPS, PKI}. Assuming well
behaved certificate authorities and modern browsing software, TLS and related
protocols, when properly deployed, mitigate myriad attacks on authentication
confidentiality.

However, as a \textit{communication} protocol, TLS only guarantees the integrity
of each \textit{end to end communication} via message authentication code
(MAC)~\cite{TLS1.2}. But protected encrypted communications mean nothing if the
contents of those communications are corrupted before the fact. Hence, the
integrity of resources at the application layer (rather than the transport
layer) is outside of the model addressed by TLS and HTTPS~\cite{TLS1.2, HTTPS}.

Attacks on resource integrity can be considered a subset of \emph{Supply Chain
Attacks} (SCA). Rather than attack an entity directly, SCAs are the compromise
of an entity's software source code (or any product) via cyber attack, insider
threat, upstream asset compromise, trusted hardware/vendor compromise, or other
attack on one or more phases of the software development life
cycle~\cite{NIST-SCA}. These attacks are hard to detect, even harder to prevent,
and have the goal of infecting and exploiting targets and victims by abusing the
trust between consumer and reputable software vendor~\cite{SCA}.

Ensuring the integrity of resources exchanged over the internet despite SCAs and
other active attacks is a hard and well studied problem~\cite{MD5Header,
HTTP1.1, HTTPS, SRI, LF, OpenPGP1, DNSSEC, PKI}. For a long time, the de facto
standard for addressing this risk in the generic case is with the use of
\textit{checksums} coupled with some secure transport medium like TLS/HTTPS.
Checksums in this context are cryptographic digests generated by a cryptographic
hashing function run over the resource's file contents. When a user downloads a
file from some source, they are expected to run the same cryptographic hashing
function over their version of the resource, yield a local checksum, and match
it with the authoritative checksum given to them from said source.

However, checksums come up short as a solution to the resource
integrity problem. Foremost is a well-understood but harsh reality: \emph{user-apathy}---a
non-trivial number of users will not be burdened with manually calculating
checksums for the resources they download. While detailing how they gained
unauthorized access to the servers, one of the hackers behind the 2016 breach of
Linux Mint's distribution system went so far as to comment (in respect to
checksums): ``Who the [expletive] checks those anyway?''~\cite{SCA-MINT3}.
Hardly unique to checksum calculation, cryptographic schemes from HTTPS to PGP
have found user apathy a difficult problem space to navigate~\cite{PGPBad,
Clickthrough}.

Even if a user felt the urge to manually calculate a checksum, they must search
for the corresponding authoritative checksum to verify that calculation. As
there is no standard storage or retrieval methods for checksums, they could be
stored anywhere, or even in multiple different locations that must then be kept
consistent; users are not guaranteed to find an authoritative checksum, even if
they are published online somewhere. If they do manage to find the authoritative
checksum and also recognize the checksums are different, the user is then
expected to ``do the right thing,'' whatever that happens to be in context.

Then there is the futility of \emph{co-hosting} a resource and its checksum on the same
distribution system. While cost-effective compared to hosting two or more
discrete systems---one for the resource and one for the resource's
checksum---an attacker that compromises a single distribution system hosting
a resource and its checksum can mutate both, rendering the checksum
irrelevant. The co-hosting problem was demonstrated by the 2016 hack of Linux Mint's distribution
server~\cite{SCA-MINT1, SCA-MINT2}.

Checksums as they are employed currently are not effective at guaranteeing
resource integrity. Recognizing this, some corporations and large entities rely
instead on PKI-based approaches such as digital signature validation and code
signing~\cite{PKI}. These roll-your-own solutions, often proprietary, have been
deployed successfully to mitigate resource integrity attacks in mature software
package ecosystems (\eg Debian/apt, Red Hat/yum, Arch/pacman) and walled-garden
app stores like Google Play, Apple App Store, and the Microsoft Store.

\PUNT{Unfortunately, ... --> (solution proposal)}

Unfortunately, not all resources available on the internet are acquired through
software package ecosystems with built-in PKI support, nor are all resources
software binaries; moreover, these PKI schemes are not compatible with one
another and cannot scale to secure arbitrary resources on the internet without
significant cost and effort. Worse, roll-your-own PKI is hard to get
right~\cite{PKI}, implying systems built atop them are inherently more
\emph{fragile}---susceptible to malfunction due to small errors or
misconfigurations.

In this paper, we propose \SYSTEM{}, a novel approach for verifying the
integrity of resources downloaded over the internet that is a complete
replacement for traditional checksums.

We view the problem with four key concerns in mind: a) implementations must
provide security guarantees transparently without adding any extra burden on the
end user in the average case---here, an optimal solution avoids relying on the
user to overcome apathy in the interest of security; b) configuring the
validation method is simple for developers and system operators to integrate and
deploy while ensuring configuration of a potentially-expensive discrete
secondary system to host checksums is unnecessary; c) the validation method is
not tightly coupled with any particular highly-available system; and d) no
application or website source code changes or end user -facing web server/web
infrastructure alterations are necessary. We implemented \SYSTEM{} as two
proof-of-concept Google Chrome extensions: \DNSSYS{} and \DHTSYS{}. Our
\DNSSYS{} implementation uses DNSSEC-secured DNS as its highly available backend
while our \DHTSYS{} implementation relies on an OpenDHT-based dummy backend.

We then evaluate the security, scalability, and performance of our automated
defense against resource corruption and demonstrate the effectiveness and
practicality of the \SYSTEM{} approach. Specifically, we find no additional
obstacles to efficient deployment at scale outside of those imposed by the
chosen authenticated distributed high availability system.

For the proof-of-concept \DNSSYS{} implementation, we find the only practical
obstacle to immediate deployment to be the adoption of DNSSEC (cf.
\secref{discussion}). We further provide a publicly accessible empirical
demonstration of \DNSSYS{}'s protective utility via a patched HotCRP instance
(cf. \secref{availability}). We observed no download performance overhead
compared to downloads without \DNSSYS{}.

In summary, our primary contributions are:

\begin{itemize}

  \item We propose a practical approach to defending against receiving corrupted
  or compromised resources over the internet. Contrasted with current solutions,
  our concrete implementations require no app/website source code or end user
  facing web server/web infrastructure changes, do not employ unreliable
  heuristics, do not interfere with other protocols or software extensions that
  might also deal with download security, and can be transparently deployed
  without adding to application/infrastructure fragility; \eg Chrome clients
  with \DNSSYS{} installed will have their downloads secured while the user
  experience of clients without the extension remains completely unaffected.

  \item We present our prototype \SYSTEM{} implementations: \DNSSYS{} and
  \DHTSYS{}. Both are implemented as Google Chrome extensions. We specifically
  demonstrate \DNSSYS{}'s effectiveness in automatically and transparently
  mitigating the accidental consumption of compromised resources from a
  compromised HotCRP server. To the best of our knowledge, this is the
  first system providing such capabilities with marginal deployment cost
  and, unlike a traditional checksum-based approach, does not require the end
  user to overcome apathy in the average case.

  \item We extensively evaluate the security, performance (overhead), and
  deployment costs of \DNSSYS{}. We find that our approach is more effective
  than checksums for mitigating resource integrity attacks. Further, we show
  \DNSSYS{} is capable of detecting a wide variety of real-world integrity
  errors, significantly raising the bar for the attacker. \DNSSYS{}, as it is
  backed by DNS, is immediately deployable at scale for entities that secure
  their DNS zone(s) with DNSSEC. Finally, we observed no download performance
  overhead compared to downloads without \DNSSYS{}.

\end{itemize}

We release our \DNSSYS{} and \DHTSYS{} proof-of-concept implementations to the
community as open source software to promote exploration of the \SYSTEM{}
approach (cf. \secref{availability}).
