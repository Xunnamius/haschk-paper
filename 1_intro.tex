\section{Introduction} \label{sec:introduction}

In 2010, through compromising legitimate applications available on trusted
vendor websites, nation-state actors launched the Havex malware, targeting
aviation, defense, pharmaceutical, and petrochemical companies in Europe and the
United States~\cite{SCA-HAVEX1, SCA-HAVEX2}. In 2012, attackers compromised an
official phpMyAdmin download mirror hosted by reputable software provider
SourceForge. The backdoored version of the popular database frontend was
downloaded by hundreds of users, potentially allowing attackers to gain access
to private customer data~\cite{SCA-PMA1, SCA-PMA2}. In 2016, attackers broke
into the Linux Mint distribution server and replaced a legitimate Mint ISO with
one containing a backdoor, infecting hundreds of machines with the
malware~\cite{SCA-MINT1, SCA-MINT2}. Over a four day period in 2017, users of
the popular HandBrake open source video transcoder on Mac/OSX were made aware
that, along with their expected video software, they may have also downloaded a
trojan that was uploading their sensitive data to a remote
server~\cite{SCA-HB1}. HandBrake developers recommended users perform checksum
validation to determine if their install was compromised~\cite{SCA-HB2}.

As every internet user is certainly aware, downloading resources over the
internet comes with considerable risk. This risk can be divided into three
categories: response authentication, communication confidentiality, and resource
integrity. Response authentication allows us to determine if a response received
indeed originates from its purported source. This can be accomplished through,
for instance, the adoption of a Public Key Infrastructure (PKI)
scheme~\cite{PKI}. Communication confidentiality, on the other hand, allows us
to keep the data transacted between two or more parties private except to said
parties. This is can be accomplished through some form of encryption, such as
AES~\cite{AES}. Finally, resource integrity allows us to verify that the data we
are receiving is the data we are expecting to receive.

When it comes to response authentication and communication confidentiality
concerns on the internet, the state of the art in attack mitigation is Transport
Layer Security (TLS) and its Hyper Text Transfer Protocol (HTTP)/PKI based
implementation, HTTPS~\cite{TLS1.2, TLS1, TLS0, HTTPS, PKI}. Assuming well
behaved certificate authorities and modern browsing software, TLS and related
protocols, when properly deployed, mitigate myriad attacks on authentication
confidentiality.

However, as a \textit{communication} protocol, TLS only guarantees the integrity
of each \textit{end to end communication} via message authentication code
(MAC)~\cite{TLS1.2}. But protected encrypted communications mean nothing if the
contents of those communications are corrupted before the fact. Hence, the
integrity of resources at the application layer (rather than the transport
layer) is outside of the model addressed by TLS and HTTPS~\cite{TLS1.2, HTTPS}.

Attacks on resource integrity can be considered a subset of \emph{Supply Chain
Attacks} (SCA). Rather than attack an organization directly, SCAs are the
compromise of an organization's software source code (or any product) via cyber
attack, insider threat, upstream asset compromise, trusted hardware/vendor
compromise, or other attack on one or more phases of the software development
life cycle. These attacks are hard to detect, even harder to prevent, and have
the goal of infecting and exploiting victims by abusing the trust between
consumer and software vendor~\cite{SCA}.

Ensuring the integrity of resources exchanged over the internet despite SCAs and
other active attacks is a hard and well studied problem~\cite{MD5Header,
HTTP1.1, HTTPS, SRI, LF, OpenPGP1, DNSSEC, PKI}. For a long time, the de facto
standard for addressing this risk in the generic case is with the use of
\textit{checksums} coupled with some secure transport medium like TLS/HTTPS.
Checksums in this context are cryptographic digests generated by a cryptographic
hashing function run over the resource's file contents. When a user downloads a
file from some source, they are expected to run the same cryptographic hashing
function over their version of the resource, yield a local checksum, and match
it with the authoritative checksum given to them from said source.

However, checksums have come up short as a viable solution to the resource
integrity problem. Foremost is a well-understood but harsh reality: the clear
majority of users will not be burdened with manually calculating checksums for
the resources they download. While detailing how they gained unauthorized access
to the servers, one of the hackers behind the 2016 breach of Linux Mint's
distribution system went so far as to comment (in respect to checksums): ``Who
the [expletive] checks those anyway?''~\cite{SCA-MINT3}.

Even if a user felt the urge to manually calculate a checksum, they must search
for the corresponding authoritative checksum to verify that calculation. As
there is no standard storage or retrieval methods for checksums, they could be
stored anywhere, or even in multiple different locations that must then be kept
consistent; users are not guaranteed to find an authoritative checksum, even if
they are published online somewhere. If they do manage to find the authoritative
checksum and also recognize the checksums are different, the user is then
expected to ``do the right thing,'' whatever that happens to be in context.

Then there is the futility of co-locating a resource and its checksum on the same
distribution system. While cost effective compared to hosting two or more
discrete systems---one hosting the resource and one hosting the resource's
checksum---an adversary that compromises a single distribution system hosting
both a resource and its checksum can mutate both, rendering the checksum
irrelevant; this was the case with the 2016 hack of Linux Mint's distribution
server~\cite{SCA-MINT1, SCA-MINT2}.

Checksums as they are employed currently are not effective at guaranteeing
resource integrity. Recognizing this, some corporations and large organizations
rely instead on PKI-based solutions such as digital signature validation and
code signing~\cite{PKI}. These solutions have been deployed successfully to
mitigate resource integrity attacks in mature software package ecosystems (\eg
Debian/apt, Red Hat/yum, Arch/pacman) and walled-garden app stores like Google
Play, Apple App Store, and the Microsoft Store.

\PUNT{Unfortunately, ... --> (solution proposal)}

Unfortunately, not all resources available on the internet are acquired through
software package ecosystems with builtin PKI support, nor are all resources
software binaries; moreover, these PKI schemes are not compatible with one
another and cannot scale to secure arbitrary resources on the internet without
significant cost and effort. Worse, roll-your-own PKI is \emph{hard to get
right}~\cite{PKI}, implying systems built atop them are inherently more
\emph{fragile}---susceptible to malfunction due to small errors or
misconfigurations.

In this paper, we propose \SYSTEM{}, a novel method of verifying the integrity
of resources downloaded over the internet that is a complete replacement for
traditional checksums. We approach the problem with four key concerns in mind:
a) implementations provide security guarantees transparently without adding any
extra burden on the end user, \ie neither grappling with a new UI nor any
additional labor is required during standard usage; b) configuring the
validation method is simple for service administrators and system operators to
integrate and deploy while ensuring configuration of a potentially-expensive
discrete secondary system to host checksums is unnecessary; c) the validation
method is not tightly coupled with any particular highly-available system; and
d) no new HTML or JavaScript language additions, application source changes, or
user-facing web server/infrastructure alterations are necessary. We implement
\SYSTEM{} as a proof-of-concept Google Chrome extension as well as a patch to
the FileZilla FTP client.

We evaluate the security, scalability, and performance of our automated defense
against resource corruption to demonstrate the effectiveness and high
practicality of the \SYSTEM{} approach. Specifically, we find no obstacles to
efficient scalability given choice of distributed system and no performance
overhead compared to downloads without \SYSTEM{}. We further provide a publicly
accessible empirical demonstration of \SYSTEM{}'s protective utility via a
patched HotCRP instance\footnote{The patched HotCRP instance is available at
https://tinyurl.com/dnschk-hotcrp}.

In summary, our primary contributions are:

\begin{itemize}

  \item We propose a novel practical defense against receiving corrupted or
  compromised resources over the internet. Contrasted with current solutions,
  our defense requires no source code or infrastructure changes at any level
  (other than DNS), does not employ unreliable heuristics, does not interfere
  with other software or extensions that also handle download security, and can
  be transparently deployed without adding to the \textit{fragility} of
  DNSSEC-enabled systems; \ie, it protects users whose software implements
  \SYSTEM{} while remaining unnoticeable to users whose software does not.

  \item We present our prototype \SYSTEM{} implementations for Google Chrome and
  FileZilla and demonstrate their effectiveness in automatically and
  transparently mitigating the accidental consumption of compromised resources
  from a compromised server hosting a compromised web portal. To the best of our
  knowledge, this is the \emph{first} system providing such capabilities with
  little implementation cost while requiring no additional work from the end
  user.

  \item We carefully and extensively evaluate the security, scalability, and
  performance of the \SYSTEM{} approach and provide a publicly accessible
  empirical demonstration of its protective utility.

\end{itemize}

We release the \SYSTEM{} solution to the community as open source software to
prompt exploration of the \SYSTEM{} approach\footnote{The \SYSTEM{} Chrome
extension is available at https://tinyurl.com/dnschk-actual}.
