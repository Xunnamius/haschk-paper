\section{The \SYSTEM{} Protocol} \label{sec:approach}

In this section, we describe the components of the \SYSTEM{} protocol, step
through each in detail, and then introduce our proof-of-concept implementations
of these components.

\TODO{Add Visio graphic 1 here.}

\subsection{Participants}

\noindent\textbf{User.} The end \emph{user} is the entity, human or otherwise,
with the goal of verifying the integrity of the resource they just downloaded.
\\

\noindent\textbf{Resource.} A \emph{resource} is any data provided by the server
to the user. A resource may or may not be protected by \SYSTEM{}, depending on
the server and backend. In the case where the resource is not protected by
\SYSTEM{}, false positives must not occur. \\

\noindent\textbf{Provider.} The \emph{provider} is the entity in control of both
the server and backend with the goal of ensuring the integrity of resources
downloaded from their system. \\

\noindent\textbf{\SYSTEM{} Frontend.} The \emph{frontend} is responsible for
calculating the Uniform Resource Name (URN) and Backend Domain (BD) of the
resource downloaded from the server. Afterwards, the frontend queries the
backend using this URN and, if an integrity violation is detected, quarantines
the resource and warns the user. \\

\noindent\textbf{Server.} The \emph{server} is a distribution system (hopefully)
controlled by the provider that hosts resources for download. It can be internal
or external, a single server or many, first-party or third-party. \\

\noindent\textbf{\SYSTEM{} Backend.} The \emph{backend} is responsible for
advertising a queryable listing of URNs that \SYSTEM{} frontends can use to
judge the legitimacy of downloads. It is a high availability system that is
wholly separate from the server (not co-hosted) and controlled by the provider.

\subsection{Protocol Overview}

When a user finishes downloading a resource from the provider's server, the
frontend runs the resource's contents through a SHA-256 hashing function,
yielding a 256-bit digest. Any hashing function can be used so long as it is
pre-image and collision resistant~\cite{Rogaway}. This digest is used to
construct a hash-based Uniform Resource Name (URN) uniquely identifying the
resource. Additionally, a Backend Domain (BD) is derived from the domain name of
the server. The frontend uses the BD in an implementation-dependent manner to
locate and query the backend, checking for the existence of the constructed URN
and essentially asking: \emph{``is this a compromised resource?''} If the URN
is found, a negative response is returned indicating a verified resource. If the
URN is not found, a positive response is returned indicating a compromised
resource.

If the query returns a positive response: (1) the user should be warned pursuant
to the recommendations of Akhawe et al~\cite{Akhawe} (avoid warning fatigue, be
invisible), Cherubini et al~\cite{Cherubini} (simple non-technical language,
secure default action), Modic et al~\cite{Modic} (issue warnings from a position
of authority), and others; (2) the download should be deleted, renamed, or
otherwise made inaccessible/quarantined by default; and (3) the user should
still be allowed to ``click through'' and override the warning and the default
quarantine behavior, though this should be less convenient than the default
action~\cite{Cherubini}. Google Chrome has implemented something similar as part
of its redesigned dangerous download warning UX, empirically demonstrating it to
be an effective countermeasure to click through in the context of
potentially-compromised downloads~\cite{ChromeClickThrough}.

If the query returns a negative response, the frontend should indicate this as
inconspicuously as possible to avoid warning/popup fatigue~\cite{Akhawe,
Cherubini} and habituation~\cite{Sunshine}. For example, our frontend
implementation simply changes its icon when downloads are successfully verified
and only issues popup warnings when compromised downloads are positively
identified.

To prevent false positives, integrity checking is skipped if the backend's
location is unresolvable or \SYSTEM{} is not properly deployed. Determining when
this is the case is implementation-dependent. To prevent false-negatives, when
\SYSTEM{} is properly deployed and a URN is not found during lookup, the backend
will always respond in the positive. As a result, it is not possible to only
secure ``some'' resources on a server. When a provider adopts \SYSTEM{}, it is
an all or nothing endeavor.

\subsubsection{Deriving the Backend Domain (BD)}

Before we can communicate with a provider's backend, we require some scheme to
locate it. We refer to this scheme as deriving the \emph{Backend Domain} (BD).
The BD is some identifier that allows the frontend to locate the backend. For
Domain Name System (DNS)-based backends, this might be the Second-Level Domain
(2LD) taken from the server URI's host subcomponent~\cite{RFC3986}. \\

Example 1: an FTP frontend (\eg{Filezilla, Transmit, et cetera}) downloading a
resource from an FTP server at
\texttt{ftps://un:pw@ftp.example1.com:8080/some/resource} has a host
subcomponent of \texttt{ftp.example1.com} and a BD of \texttt{ftp.example1.com}
or \texttt{example1.com}. \\

Example 2: a browser frontend (\eg{wget, Internet Explorer, et cetera})
downloading a resource from a web server at
\texttt{https://s4.ll.cdn.example2.com/some/resource} has a host subcomponent of
\texttt{s4.ll.cdn.example2.com} and a BD of \texttt{cdn.example2.com} or
\texttt{example2.com}. \\

Depending on the implementation, a frontend or backend may not be using URIs and
DNS to transact information over the internet at all. An example of this is a
Distributed Hash Table (DHT) based backend. In such a case, any derivation
algorithm (or no derivation at all, \eg{the BD is hardcoded}) can be used as
long as the BD is eventually known to the frontend.

\subsubsection{Constructing Uniform Resource Names (URN)}

To ensure the integrity of arbitrary resources, we require some method to
uniquely and durably identify those resources. We accomplish this through the
adoption of the informal IETF draft for the construction of hash-based
\emph{Uniform Resource Name} (URN) namespace~\cite{draft-URN}, which the
frontend follows when calculating URNs for each resource downloaded. Through
whatever implementation-specific method, the backend must ``advertise'' or allow
lookups against a set of expected URNs corresponding to the resources hosted on
the provider's server, even if those resources have unstable access paths or
URIs; \eg{,when resources are hosted externally, on download mirrors, on CDNs,
et cetera}. This requirement is satisfied by implementations combining URNs with
the BD, thus durably associating the URNs calculated in the frontend with the
URNs advertised by a provider's backend regardless of where the corresponding
resources are hosted on the provider's server.

Since the backend advertising URNs is \emph{never} co-hosted alongside the
system that distributes the corresponding resources---like a web or FTP
server---\SYSTEM{} retains the ability to protect users from dangerous downloads
\emph{even when the system distributing the resource has been completely
compromised}. This is not true of prior approaches to automated checksum
verification of arbitrary resources~\cite{Cherubini}.

\subsection{Protocol Implementation}

\TODO{Add Visio graphic 2 here.}

\TODO{Add metrics about solution LoC and rewrite the rest of this subsection.}

For Domain Name System (DNS)-based backends, this might be the Second-Level
Domain (2LD) or Third-Level Subdomain (3LD) based on the server URI's host
subcomponent~\cite{RFC3986}. What follows is a generic BD derivation and
resolution algorithm for DNS-based backends:

\begin{enumerate}
    \item Derive 
\end{enumerate}

Finally, we choose between the 3LD and 2LD by issuing a query---first to the 3LD
and then, if not found there, to the 2LD---to determine if \SYSTEM{} is properly
deployed. ``Proper deployment'' here is implementation-specific: the backend
should respond in a predetermined way to indicate the presence of \SYSTEM{} to
the frontend. For example, a DNS-based backend might respond with a specially
crafted TXT record to queries against the 3LD.

We chose to include both 3LD and 2LD in the derivation and resolution process
for added flexibility to providers who may want to host a backend on a subdomain
rather than their root domain.

Our \SYSTEM{} implementation consist of two parts: ...

Hence, proper deployment of the \SYSTEM{} approach necessitates the existence of
a separate distribution mechanism for advertising ``safe'' URNs. The idea of
using some distributed storage service to query a global mapping of such values
is not new and may seem straightforward, but there are some deceptively complex
implementation challenges.

Foremost is determining which backend should be queried for a
given resource. We refer \emph{backend domain} for a download. \TODO{Explain.}

An additional challenge is the choice of backend to host an provider's URN
mappings. There has been a lot of effort put into researching, designing, and
standardizing several high availability high performance storage technologies,
some of which web-facing providers and IT teams are already quite familiar with
and pay for, \eg{the Domain Name System (DNS)}. Other candidate backends include
DHTs, storage clusters, relational and non-relational databases, and any high
availability key-value store reasonably capable of guaranteeing the authenticity
of its responses.

We implement \SYSTEM{} as a proof-of-concept Google Chrome extension. It works
with DNS and Ring OpenDHT as high availability backends. Our Chrome extension
does not make any modifications to the Chrome user interface or viewport other
than the extension icon in the toolbar. Further, the extension is virtually
transparent to end users when downloads are matched to the backend or \SYSTEM{}
has not been deployed to a domain. However, if a failure is experienced (\ie{a
uncommon case}), the extension will alert the user to the dangerous download via
toolbar icon and popup interface.

\TODO{Talk a bit about deployment.}

An ideal implementation is able to rely on Google Chrome's dangerous download
UI~\cite{ChromeClickThrough}.
