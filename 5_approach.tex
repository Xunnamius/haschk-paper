\section{The \SYSTEM{} Protocol} \label{sec:approach}

\TODO{Rewrite this section}

\TODO{Can handle multiple downloads at once.}

\TODO{There is a problem here as I still do not understand what the system is.
The approach section does not read like an approach to me, but more the sort of
philosophical guidelines behind the work. That approach section has a few
redundancies with the earlier motivation and challenges listed in other
sections. More importantly, it doesn't provide a whole lot of technical
information about what is done. That lack of technical information becomes a
problem once I get to this section and you start telling me how threats are
mitigated by various steps in the proposed solution: I still don't understand
the solution. So, I think the paper needs some reorganization. One thing that
has to happen is make section 4 much more concrete. (Hopefully that is where you
are plannign to add the diagrams, which will help). I also believe that the
implementation needs to be hoisted up to section 4. It is possible that once
that is done, you won't really need to add much to section 4. Then I believe the
parts that describe how the approach mitigates threats will make more sense.}

In this section we detail the \SYSTEM{} approach.

To achieve these goals, we first require some method to uniquely identify
individual resources. This can be addressed with checksums themselves, as they
are the output of cryptographic hashing functions that are pre-image, second
pre-image, and collision resistant. So long as the chosen function is not known
to be weak, the output can be assumed unique per resource~\cite{Rogaway}. Given
this, we adopt the informal IETF draft for hash-based Uniform Resource Name
(URN) namespaces~\cite{draft-URN} to both uniquely identify resources and, when
combined with an \emph{origin domain} (below), additionally associate the
resource with the entity distributing it. URNs make this association durable: an
entity uses a high availability mapping to publicly advertise the URNs of
resources they offer for download, which can identify resources whose access
path or URI is not stable (\eg{resources hosted on download mirrors and CDNs}).

Since the high availability system advertising URNs is not co-hosted with the
system that distributes the corresponding resources---like a web or FTP
server---\SYSTEM{} retains the ability to protect users from dangerous downloads
\emph{even when the system distributing the download has been completely
compromised}. This is not true of prior approaches to automated checksum
verification of arbitrary resources. \TODO{This is a strong statement. Maybe add
more citations to back it up?}

\subsection{Overview}

\SYSTEM{} implementations consist of two parts: the actual client---like Google
Chrome or Filezilla---and the high availability system against which URN queries
are made. Immediately after a resource is obtained by the client---e.g., when a
download link is clicked---a ``non-authoritative'' cryptographic digest
(checksum) is generated by running a cryptographic hashing function over the
contents of the resource file. This checksum is used to construct the URN that
uniquely fingerprints that resource in accordance with the draft
spec~\cite{draft-URN}. The URN can be further encoded as individual
implementations demand. Our implementation replaces all colons (``:'') in the
URN with dashes and removes all padding characters so that URNs form valid URLs.

Next, \SYSTEM{} uses the URN and the origin domain to query the high
availability system. At this point, the system will respond with either (1) a
confirmation that the URN exists, in which case \SYSTEM{} determines the
download to be safe or (2) a rejection when the URN is not found, in which case
\SYSTEM{} determines the download to be unsafe. In the case where an ``unsafe''
determination is made, some implementation-specific action should be taken that
accounts for user apathy to mitigate risk.

\subsection{Accounting for User Apathy}

Human factors such as user apathy have stymied cryptographers for decades.
Schemes that are otherwise reasonably cryptographically solid can fail
catastrophically due to human error, confusion, aversion to inconvenience, or
simple lack of interest. Some users are likely to avoid using a security measure
altogether if it presents even a minor obstacle to immediate
gratification~\cite{PGPBad, Egelman1, Egelman2, Modic, Reeder, Silic, Bianchi,
Akhawe, Cherubini}.

\TODO{Remove all this redundancy.}

With this in mind, the primary goal of \SYSTEM{} is to side-step the human
factor by providing a completely transparent and unobtrusive, fully-automated
method of checksum calculation and verification in the common case. In the
uncommon case, when a download is determined ``unsafe'', we 1) clearly, visibly,
and simply assert the danger of the download and 2) value user security over
choice as suggested by Cherubini et al~\cite{Cherubini} and appeal to authority
as suggested by Modic et al~\cite{Modic}. This means deleting, renaming, or
otherwise making the unsafe resource inaccessible by default, forcing the user
to confront the problem with no easy avenue to click-through the warning, and
ensuring the warning appeals to authority. In the more common case where a
``safe'' determination is made, \SYSTEM{} should remain unobtrusive or even
invisible to the user.

\subsection{Mitigating the Co-Hosting Problem}

Funding and maintaining a single server/system to host assets can be extremely
cost-effective in the short term compared to hosting two or more discrete
systems, such as one to host a resource and another to host a resource's
checksum. Unfortunately, this creates a single point of failure: an attacker
that compromises this system can both corrupt the resource and update the
checksum to match. Hence, co-hosting a resource and its corresponding checksum
on the same system virtually negates the effectiveness of having a checksum at
all.

Hence, proper deployment of the \SYSTEM{} approach necessitates the existence of
a separate distribution mechanism for advertising ``safe'' URNs. The idea of
using some distributed storage service to query a global mapping of such values
is not new and may seem straightforward, but there are some deceptively complex
implementation challenges.

Foremost is determining which high availability system should be queried for a
given resource. We refer \emph{origin domain} for a download. \TODO{Explain.}

An additional challenge is the choice of high availability system to host an
entity's URN mappings. There has been a lot of effort put into researching,
designing, and standardizing several high availability high performance storage
technologies, some of which web-facing providers and IT teams are already quite
familiar with and pay for, \eg the Domain Name System (DNS). Other candidate
high availability systems include DHTs, storage clusters, relational and
non-relational databases, and any high availability key-value store reasonably
capable of guaranteeing the authenticity of its responses.

\subsection{Implementations}

We implement \SYSTEM{} as two proof-of-concept Google Chrome extensions. They
work with DNS and Ring OpenDHT as their high availability backends,
respectively. Our Chrome extensions do not make any modifications to the Chrome
user interface or viewport other than the extension icon in the toolbar.
Further, the extensions are transparent to end users when downloads are matched
to the backend. However, if a failure is experienced during NAC Validation (\ie
a uncommon case), the extensions will alert the user to the dangerous download
via toolbar icon and popup interface. We additionally note the \SYSTEM{}
approach is not limited to browsers. It can also be incorporated into, for
instance, FTP and SSH clients (\eg{rsync}), mobile apps, etc.

Our implementation was designed with this guidance in mind, with ideal
implementations able to rely on Google Chrome's dangerous download
UI~\cite{ChromeClickThrough}. \TODO{talk about how the dangerous download UI is
"from an authority," is harder to click through, and that this is verified by
the Chrome dev team}.

\subsection{Overview XXXX}

Immediately after a resource download is first detected, the extensions compute
an RI from the full URL path of the resource. For the purposes of our
implementations, we calculate the RI as a hash digest of the path component of
the URL pointing to the resource. For example, consider a web resource hosted at
\texttt{https://somesite.com/var/downloadme.txt}. Our implementations would hash
\texttt{/var/downloadme.txt} to yield an RI. Note that there are several ways a
browser extension could calculate an RI.

Next, we determine the so-called \emph{Origin Domain} (OD). The OD is the base
domain used to query the backend and should always be the Second-Level Domain
(SLD) fragment of the \emph{active browser tab's URL}, \ie the URL of the tab
that initiated the download. For example: \texttt{somesite.com} would be the OD
for a Chrome tab at URL \texttt{frag.something.somesite.com} and
\texttt{fakesite.io} would be the OD for a Chrome tab at
\texttt{git.fakesite.io}.

The OD is appended to the Primary Label (PL), which is then appended to the RI
Sub-Label (SL). The PL is a standard string used to more easily identify the
backend records our implementations rely upon; we used ``\_haschk''. It will
always appear as the third-level domain following the OD in any query to the
backend. The SL is a standard string used to identify backend entries that
contain RIs; we used ``\_ri'' in our implementations. The resulting
construction, consisting of \texttt{SL.PL.OD} (\eg
\texttt{\_ri.\_haschk.fakesite.io}), is appended to the RI calculated earlier.
This forms the subject of the query to our backend, whereafter the backend
responds with the AC or an indication that the RI-to-AC mapping was not found.

To remain in compliance with DNS protocol label limits, we chose to split the
RI---a 64 character alphanumeric string---into two labels separated by a period.

The ultimate query sent to the backend consists of an OD (\eg
\texttt{fakesite.io}), a PL (static; \ie \texttt{\_haschk}), an SL (static; \ie
\texttt{\_ri}), and an RI broken into two parts (\ie \texttt{RI1} and
\texttt{RI2}). This yields the following (with an example on line 2): \\
\makebox[\linewidth]{\texttt{RI1.RI2.SL.PL.OD}}
\makebox[\linewidth]{\texttt{RI1.RI2.\_ri.\_haschk.fakesite.io}}

Finally, the backend responds to our query and NAC Validation is performed. If
NAC Validation succeeds, our extensions render a ``safe'' judgement via the
extension UI. If NAC Validation fails, our extensions render an ``unsafe''
judgement. If the backend response indicates the RI mapping we queried does not
exist, there are two possible outcomes: the extensions render a ``neutral''
judgement if they are not operating under strict mode conditions, otherwise an
``unsafe'' judgement is rendered (as if NAC Validation had taken place and
failed).

\subsection{Deployment and Scalability}

\TODO{Explain how \SYSTEM{} would be deployed}

In respect to our implementation, storing cryptographic data in DNS resource
records is not unprecedented. The DNS-Based Authentication of Named Entities
(DANE) specification~\cite{DANE1, DANE2, DANE3} defines the ``TLSA'' and
``OPENPGPKEY'' DNS resource records to store cryptographic data. These resource
record types, along with ``CERT''~\cite{CERT}, ``IPSECKEY''~\cite{IPSECKEY},
those defined by DNS Security Extensions (DNSSEC)~\cite{DNSSEC}, and others
demonstrate that storing useful cryptographic data retrievable through the DNS
network is feasible at scale. Due the unique requirements of DNS, however, we
use ``TXT'' records to map Resource Identifiers to Authoritative Checksums. In
accordance with RFC 5507~\cite{RFC5507}, a production implementation
implementation would necessitate the creation of a new DNS resource record type
as no current resource record type meets our requirements.

\subsection{Resolving Origin Domain in the Browser}

To execute a resource integrity attack on a web server, an attacker generally
has two paths. They can mutate the resource in place, which would cause NAC
Validation to fail. They could also mutate the web page hosting the resource,
replacing the resource's hyperlink with a malicious hyperlink pointing to a
compromised resource on the attacker's remote system. Implementations will catch
this due to how we calculate the Origin Domain (OD).

To prevent such implementation-specific attacks, we make a distinction between
the domain a resource's hyperlink might be pointing to (which might belong to
the attacker) and the OD, which is the domain of the web document that contains
said hyperlink. The scope of the OD is at the tab level, meaning there is one OD
determined for each open browser tab.

In our implementations, we rely on the Chrome Tabs and WebRequest APIs to
associate downloads with ODs. Our extensions are implemented such that the OD is
determined as early as possible in a Chrome tab's navigation lifecycle. Further,
in our implementations, determined ODs are ultimately ordered as a LIFO
construction. This ensures the resource-to-tab mappings remain accurate in the
case where two tabs share the same OD when a resource download is observed.

\subsection{Attacking Origin Domain Resolution in the Browser}

While determining ODs, a clever attacker might attempt to fool this process by
redirecting users one or more times before triggering a direct download of a
compromised resource. The redirects would allow an attacker to completely
manipulate the OD, with the ability to trick an unsuspecting user into
downloading a compromised resource with valid entries in the backend system.

We mitigate this threat by leveraging JavaScript's document-wide \emph{trusted
event}~\cite{TrustedEvents} delegation capability. Specifically, when a tab
navigation event is observed, the tab is flagged \texttt{suspicious} by default
and the determined OD is not updated (\ie it remains at its previous value). If
the user interacts with the tab (\ie a trusted click or key press event is
observed after navigation completes), the \texttt{suspicious} flag is cleared
and the OD is updated. If another tab navigation event occurs without user
interaction first (\eg a quick redirect), this process repeats recursively. If a
download is observed coming from a tab flagged \texttt{suspicious}, the user is
warned about the suspicious circumstances similarly to receiving an ``unsafe''
judgement.

While this mitigates the attack as described, it has the side effect of
potentially generating false positive warnings when 1) the user is redirected to
a legitimate website---such as a download mirroring service---that automatically
triggers a download after some amount of time when also 2) the user does not
interact with the page at all before the download begins. We argue such cases
are uncommon and the tradeoff here is worthy.

\subsection{Issuing Security Warnings: Privileging Security over Choice}

\TODO{Argue “override” using Chrome danger download warning UI is effective
using Chrome dev data}

In the cases where problems \emph{are} detected, a consistent minority of users
are known to ignore security warnings depending factors like an implementation's
user experience (UX), warning fatigue, user attention, et cetera~\cite{Modic,
Akhawe, ChromeClickThrough}.

Our Google Chrome implementation was designed in light of the suggestions of
Cherubini et al~\cite{Cherubini}, Tan et al~\cite{Tan}, Akhawe et
al~\cite{Akhawe}, and others: (1) we clearly, visibly, and simply assert the
danger of the download if it is dangerous, otherwise the extension should be
invisible to users and (2) we privilege security over choice by rejecting the
download by default while making it inconvenient to ignore or click through the
security warning.

An ideal implementation able to rely on Google Chrome's dangerous download
UI~\cite{ChromeClickThrough}.
