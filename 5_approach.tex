\section{The \SYSTEM{} Protocol} \label{sec:approach}

\TODO{Add Visio graphic here.}

In this section, we describe the components of the \SYSTEM{} protocol, step
through each in detail, and then introduce our proof-of-concept implementations
of these components.

\subsection{Participants}

\noindent\textbf{User.} The end \emph{user} is the entity, human or otherwise,
with the goal of verifying the integrity of the resource they just downloaded.
\\

\noindent\textbf{Resource.} A \emph{resource} is any data provided by the server
to the user. A resource may or may not be protected by \SYSTEM{}, depending on
the server and backend. In the case where the resource is not protected by
\SYSTEM{}, false positives must not occur. \\

\noindent\textbf{Provider.} The \emph{provider} is the entity in control of both
the server and backend with the goal of ensuring the integrity of resources
downloaded from their system. \\

\noindent\textbf{\SYSTEM{} Frontend.} The \emph{frontend} is responsible for
calculating the Uniform Resource Name (URN) and Backend Domain (BD) of the
resource downloaded from the server. Afterwards, the frontend queries the
backend using this URN and, if an integrity violation is detected, quarantines
the resource and warns the user. \\

\noindent\textbf{Server.} The \emph{server} is a distribution system (hopefully)
controlled by the provider that hosts resources for download. It can be internal
or external, a single server or many, first-party or third-party. \\

\noindent\textbf{\SYSTEM{} Backend.} The \emph{backend} is responsible for
advertising a queryable listing of URNs that \SYSTEM{} frontends can use to
judge the legitimacy of downloads. It is a high availability system that is
wholly separate from the server and (hopefully) controlled by the provider.

\subsection{Overview}

When a user finishes downloading a resource from the provider's server, the
frontend runs the resource's contents through a SHA-256 hashing function,
yielding a 256-bit digest. Any hashing function can be used so long as it is
pre-image and collision resistant~\cite{Rogaway}. This digest is used to
construct a hash-based Uniform Resource Name (URN) uniquely identifying the
resource. Additionally, a Backend Domain (BD) is derived from the domain name of
the server. The BD is used in an implementation-dependent manner to locate and
query the backend (or skip integrity checking if the backend's location is
unresolvable or the \SYSTEM{} protocol is not properly deployed). A positive
response to the query indicates a compromised resource while a negative response
indicates a verified resource.

If the query returns a positive result: (1) the user is warned pursuant to the
recommendations of Akhawe et al~\cite{Akhawe} (avoid warning fatigue, be
invisible), Cherubini et al~\cite{Cherubini} (simple non-technical language,
secure default action), Modic et al~\cite{Modic} (issue warnings from a position
of authority), and others; (2) the download is deleted, renamed, or otherwise
made inaccessible/quarantined by default; and (3) the user is still allowed to
``click through'' and override the warning and the default quarantine behavior,
though this should be less convenient than the default~\cite{Cherubini}. Google
Chrome has implemented something similar as part of its redesigned dangerous
download warning UX, empirically demonstrating it to be an effective
countermeasure to click through in the context of
downloads~\cite{ChromeClickThrough}.

If the query returns a negative result, the frontend should indicate this as
inconspicuously as possible to avoid warning/popup fatigue~\cite{Akhawe,
Cherubini} and habituation~\cite{Sunshine}. For example, our frontend
implementation simply changes its icon when downloads are successfully verified
and only issues popup warnings when compromised downloads are positively
identified.

\subsubsection{Deriving the Backend Domain (BD)}

\emph{Backend Domain} ...

\subsubsection{Constructing Hash-Based Uniform Resource Names (URN)}

Our goal is to ensure the integrity of arbitrary resources downloaded over the
internet. To achieve this, we require some method to durably and uniquely
identify individual resources. We accomplish this through the adoption of the
informal IETF draft for hash-based \emph{Uniform Resource Name} (URN)
namespace~\cite{draft-URN}. Combined with a BD, URNs make this association
durable: a backend must advertise the URNs of resources they offer for download,
even when those resources have unstable access paths or URI (\eg{resources
hosted externally, on download mirrors, on CDNs, et cetera}).

Since the backend advertising URNs is \emph{never} co-hosted alongside the
system that distributes the corresponding resources---like a web or FTP
server---\SYSTEM{} retains the ability to protect users from dangerous downloads
\emph{even when the system distributing the resource has been completely
compromised}. This is not true of prior approaches to automated checksum
verification of arbitrary resources~\cite{Cherubini}.

\subsection{Implementation}

Our \SYSTEM{} implementation consist of two parts: ...

\TODO{Add metrics about solution LoC}

Hence, proper deployment of the \SYSTEM{} approach necessitates the existence of
a separate distribution mechanism for advertising ``safe'' URNs. The idea of
using some distributed storage service to query a global mapping of such values
is not new and may seem straightforward, but there are some deceptively complex
implementation challenges.

Foremost is determining which backend should be queried for a
given resource. We refer \emph{backend domain} for a download. \TODO{Explain.}

An additional challenge is the choice of backend to host an
provider's URN mappings. There has been a lot of effort put into researching,
designing, and standardizing several high availability high performance storage
technologies, some of which web-facing providers and IT teams are already quite
familiar with and pay for, \eg the Domain Name System (DNS). Other candidate
backends include DHTs, storage clusters, relational and
non-relational databases, and any high availability key-value store reasonably
capable of guaranteeing the authenticity of its responses.

We implement \SYSTEM{} as two proof-of-concept Google Chrome extensions. They
work with DNS and Ring OpenDHT as their high availability backends,
respectively. Our Chrome extensions do not make any modifications to the Chrome
user interface or viewport other than the extension icon in the toolbar.
Further, the extensions are transparent to end users when downloads are matched
to the backend. However, if a failure is experienced during NAC Validation (\ie
a uncommon case), the extensions will alert the user to the dangerous download
via toolbar icon and popup interface. We additionally note the \SYSTEM{}
approach is not limited to browsers. It can also be incorporated into, for
instance, FTP and SSH clients (\eg{rsync}), other terminal applications like
wget and rsync, mobile apps, etc.

In respect to our implementation, storing cryptographic data in DNS resource
records is not unprecedented. The DNS-Based Authentication of Named Entities
(DANE) specification~\cite{DANE1, DANE2, DANE3} defines the ``TLSA'' and
``OPENPGPKEY'' DNS resource records to store cryptographic data. These resource
record types, along with ``CERT''~\cite{CERT}, ``IPSECKEY''~\cite{IPSECKEY},
those defined by DNS Security Extensions (DNSSEC)~\cite{DNSSEC}, and others
demonstrate that storing useful cryptographic data retrievable through the DNS
network is feasible at scale. Due the unique requirements of DNS, however, we
use ``TXT'' records to map Resource Identifiers to Authoritative Checksums. In
accordance with RFC 5507~\cite{RFC5507}, a production implementation
implementation would necessitate the creation of a new DNS resource record type
as no current resource record type meets our requirements.

An ideal implementation able to rely on Google Chrome's dangerous download
UI~\cite{ChromeClickThrough}.

\subsection{Deployment}

\TODO{Explain how \SYSTEM{} would be deployed}
