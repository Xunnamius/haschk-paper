\section{The \SYSTEM{} Approach} \label{sec:approach}

In this section we detail the \SYSTEM{} approach, a practical defense against
receiving corrupted or compromised resources over the internet that 1) is
automated to account for user apathy and 2) does not require co-hosting the
checksum, which creates a single point of failure and renders checksum
verification (even automated checksum verification) irrelevant.

To achieve these goals, we first require some method to uniquely identify
individual resources. This can be addressed with checksums themselves, as they
are the output of cryptographic hashing functions that are pre-image, second
pre-image, and collision resistant. So long as the chosen function is not known
to be weak, the output can be assumed unique per resource~\cite{Rogaway}. Given
this, we adopt the informal IETF draft for hash-based Uniform Resource Name
(URN) namespaces~\cite{draft-URN} to both uniquely identify resources and, when
combined with an \emph{origin domain} (below), additionally associate the
resource with the entity distributing it. URNs make this association durable: an
entity uses a high availability mapping to publicly advertise the URNs of
resources they offer for download, which can identify resources whose access
path or URI is not stable (\eg{resources hosted on download mirrors and CDNs}).

Since the high availability system advertising URNs is not co-hosted with the
system that distributes the corresponding resources---like a web or FTP
server---\SYSTEM{} retains the ability to protect users from dangerous downloads
\emph{even when the system distributing the download has been completely
compromised}. This is not true of prior approaches to automated checksum
verification of arbitrary resources. \TODO{This is a strong statement. Maybe add
more citations to back it up?}

\subsection{Overview}

\SYSTEM{} implementations consist of two parts: the actual client---like Google
Chrome or Filezilla---and the high availability system against which URN queries
are made. Immediately after a resource is obtained by the client---e.g., when a
download link is clicked---a ``non-authoritative'' cryptographic digest
(checksum) is generated by running a cryptographic hashing function over the
contents of the resource file. This checksum is used to construct the URN that
uniquely fingerprints that resource in accordance with the draft
spec~\cite{draft-URN}. The URN can be further encoded as individual
implementations demand. For instance, our \DNSSYS{} implementation replaces all
colons (``:'') in the URN with dashes and removes all padding characters so that
URNs form valid URLs.

Next, \SYSTEM{} uses the URN and the origin domain to query the high
availability system. At this point, the system will respond with either 1) a
confirmation that the URN exists, in which case \SYSTEM{} determines the
download to be safe or 2) a rejection when the URN is not found, in which case
\SYSTEM{} determines the download to be unsafe. In the case where an ``unsafe''
determination is made, some implementation-specific action should be taken that
accounts for user apathy to mitigate risk.

\subsection{Accounting for User Apathy}

Human factors such as user apathy have stymied cryptographers for decades.
Schemes that are otherwise reasonably cryptographically solid can fail
catastrophically due to human error, confusion, aversion to inconvenience, or
simple lack of interest. Some users are likely to avoid using a security measure
altogether if it presents even a minor obstacle to immediate
gratification~\cite{PGPBad, Egelman1, Egelman2, Modic, Reeder, Silic, Sunshine,
Bianchi, Akhawe, Cherubini}.

With this in mind, the primary goal of \SYSTEM{} is to side-step the human
factor by providing a completely transparent and unobtrusive, fully-automated
method of checksum calculation and verification in the common case. In the
uncommon case, when a download is determined ``unsafe'', we 1) clearly, visibly,
and simply assert the danger of the download and 2) value user security over
choice as suggested by Cherubini et al~\cite{Cherubini} and appeal to authority
as suggested by Modic et al~\cite{Modic}. This means deleting, renaming, or
otherwise making the unsafe resource inaccessible by default, forcing the user
to confront the problem with no easy avenue to click-through the warning, and
ensuring the warning appeals to authority. In the more common case where a
``safe'' determination is made, \SYSTEM{} should remain unobtrusive or even
invisible to the user.

\subsection{Mitigating the Co-Hosting Problem}

Funding and maintaining a single server/system to host assets can be extremely
cost-effective in the short term compared to hosting two or more discrete
systems, such as one to host a resource and another to host a resource's
checksum. Unfortunately, this creates a single point of failure: an attacker
that compromises this system can both corrupt the resource and update the
checksum to match. Hence, co-hosting a resource and its corresponding checksum
on the same system virtually negates the effectiveness of having a checksum at
all.

Hence, proper deployment of the \SYSTEM{} approach necessitates the existence of
a separate distribution mechanism for advertising ``safe'' URNs. The idea of
using some distributed storage service to query a global mapping of such values
is not new and may seem straightforward, but there are some deceptively complex
implementation challenges.

Foremost is determining which high availability system should be queried for a
given resource. We refer \emph{origin domain} for a download. \TODO{Explain.}

An additional challenge is the choice of high availability system to host an
entity's URN mappings. There has been a lot of effort put into researching,
designing, and standardizing several high availability high performance storage
technologies, some of which web-facing entities and IT teams are already quite
familiar with and pay for, \eg the Domain Name System (DNS). Other candidate
high availability systems include DHTs, storage clusters, relational and
non-relational databases, and any high availability key-value store reasonably
capable of guaranteeing the authenticity of its responses.

\subsection{Implementations}

We implement \SYSTEM{} as two proof-of-concept Google Chrome extensions:
\DNSSYS{} and \DHTSYS{}. They work with DNS and Ring OpenDHT as their high
availability backends, respectively. Our Chrome extensions do not make any
modifications to the Chrome user interface or viewport other than the extension
icon in the toolbar. Further, downloads work exactly the same whether or not
\DNSSYS{} or \DHTSYS{} are installed; the extensions are transparent to end
users. However, if a failure is experienced during NAC Validation (\ie a
uncommon case), the extensions will alert the user to the dangerous download via
toolbar icon and popup interface. We additionally note the \SYSTEM{} approach is
not limited to browsers. It can also be incorporated into, for instance, FTP and
SSH clients (\eg{rsync}), mobile apps, etc.

Our \DNSSYS{} and \DHTSYS{} implementations were designed with this guidance in
mind, with ideal implementations able to rely on Google Chrome's dangerous
download UI~\cite{ChromeClickThrough}. \TODO{talk about how the dangerous
download UI is "from an authority," is harder to click through, and that this is
verified by the Chrome dev team}.

\subsection{Overview XXXX}

Immediately after a resource download is first detected, the extensions compute
an RI from the full URL path of the resource. For the purposes of our
implementations, we calculate the RI as a hash digest of the path component of
the URL pointing to the resource. For example, consider a web resource hosted at
\texttt{https://somesite.com/var/downloadme.txt}. Our implementations would hash
\texttt{/var/downloadme.txt} to yield an RI. Note that there are several ways a
browser extension could calculate an RI.

Next, we determine the so-called \emph{Origin Domain} (OD). The OD is the base
domain used to query the backend and should always be the Second-Level Domain
(SLD) fragment of the \emph{active browser tab's URL}, \ie the URL of the tab
that initiated the download. For example: \texttt{somesite.com} would be the OD
for a Chrome tab at URL \texttt{frag.something.somesite.com} and
\texttt{fakesite.io} would be the OD for a Chrome tab at
\texttt{git.fakesite.io}.

The OD is appended to the Primary Label (PL), which is then appended to the RI
Sub-Label (SL). The PL is a standard string used to more easily identify the
backend records our implementations rely upon; we used ``\_dnschk''. It will
always appear as the third-level domain following the OD in any query to the
backend. The SL is a standard string used to identify backend entries that
contain RIs; we used ``\_ri'' in our implementations. The resulting
construction, consisting of \texttt{SL.PL.OD} (\eg
\texttt{\_ri.\_dnschk.fakesite.io}), is appended to the RI calculated earlier.
This forms the subject of the query to our backend, whereafter the backend
responds with the AC or an indication that the RI-to-AC mapping was not found.

To remain in compliance with DNS protocol label limits, we chose to split the
RI---a 64 character alphanumeric string---into two labels separated by a period.
We do this for both implementations, though it is only relevant with \DNSSYS{}.

The ultimate query sent to the backend consists of an OD (\eg
\texttt{fakesite.io}), a PL (static; \ie \texttt{\_dnschk}), an SL (static; \ie
\texttt{\_ri}), and an RI broken into two parts (\ie \texttt{RI1} and
\texttt{RI2}). This yields the following (with an example on line 2): \\
\makebox[\linewidth]{\texttt{RI1.RI2.SL.PL.OD}}
\makebox[\linewidth]{\texttt{RI1.RI2.\_ri.\_dnschk.fakesite.io}}

Finally, the backend responds to our query and NAC Validation is performed. If
NAC Validation succeeds, our extensions render a ``safe'' judgement via the
extension UI. If NAC Validation fails, our extensions render an ``unsafe''
judgement. If the backend response indicates the RI mapping we queried does not
exist, there are two possible outcomes: the extensions render a ``neutral''
judgement if they are not operating under strict mode conditions, otherwise an
``unsafe'' judgement is rendered (as if NAC Validation had taken place and
failed).

``Strict mode'' status, if active, prevents \DNSSYS{} and \DHTSYS{} from
rendering ``neutral'' judgements for a particular OD. The point of neutral
judgements is to allow the \SYSTEM{} approach to be incrementally adopted and
deployed on the open internet without ``breaking the internet'' or pestering the
user with false positives when downloading resources that are not explicitly
protected by our approach. For resources that are protected by our approach,
strict mode ensures there are only two possible judgements rendered by \DNSSYS{}
and \DHTSYS{} for a given OD: either ``safe'' if NAC Validation succeeds or
``unsafe'' in all other circumstances. For this reason, it is recommended that
any adopter of our approach ensure their resources are protected under strict
mode by default.

To determine if strict mode status applies to an OD, an additional backend query
is made of the form \texttt{SML.PL.OD}, where SML is the Strict Mode Sub-Label
consisting of the standard string ``\_smode''. Continuing with our previous
example, our query would take the form \texttt{\_smode.\_dnschk.fakesite.io}. If
and only if the subject of this additional query exists in the backend, strict
mode status is assumed.

\subsection{Deployment and Scalability}

\TODO{Explain how DNSCHK and DHTCHK would be deployed}

In respect to \DNSSYS{} specifically, storing cryptographic data in DNS resource
records is not unprecedented. The DNS-Based Authentication of Named Entities
(DANE) specification~\cite{DANE1, DANE2, DANE3} defines the ``TLSA'' and
``OPENPGPKEY'' DNS resource records to store cryptographic data. These resource
record types, along with ``CERT''~\cite{CERT}, ``IPSECKEY''~\cite{IPSECKEY},
those defined by DNS Security Extensions (DNSSEC)~\cite{DNSSEC}, and others
demonstrate that storing useful cryptographic data retrievable through the DNS
network is feasible at scale. Due the unique requirements of \DNSSYS{}, however,
we use ``TXT'' records to map Resource Identifiers to Authoritative Checksums.
In accordance with RFC 5507~\cite{RFC5507}, a production \DNSSYS{}
implementation would necessitate the creation of a new DNS resource record type
as no current resource record type meets the requirements of \DNSSYS{}.

\subsection{Resolving Origin Domain in the Browser}

To execute a resource integrity attack on a web server, an attacker generally
has two paths. They can mutate the resource in place, which would cause NAC
Validation to fail. They could also mutate the web page hosting the resource,
replacing the resource anchor with a malicious one that points to a compromised
resource on the attacker's remote system. \DNSSYS{} and \DHTSYS{} will catch
this due to how we calculate the Origin Domain (OD).

To prevent such implementation-specific attacks, we make a distinction between
the domain a resource's hyperlink might be pointing to (which might belong to
the attacker) and the OD, which is the domain of the web document that contains
said hyperlink. The scope of the OD is at the tab level, meaning there is one OD
determined for each open browser tab.

In our implementations, we rely on the Chrome Tabs and WebRequest APIs to
associate downloads with ODs. Our extensions are implemented such that the OD is
determined as early as possible in a Chrome tab's navigation lifecycle. Further,
in our implementations, determined ODs are ultimately ordered as a LIFO
construction. This ensures the resource-to-tab mappings remain accurate in the
case where two tabs share the same OD when a resource download is observed.

\subsection{Attacking Origin Domain Resolution in the Browser}

While determining ODs, a clever attacker might attempt to fool this process by
redirecting users one or more times before triggering a direct download of a
compromised resource. The redirects would allow an attacker to completely
manipulate the OD, with the ability to trick an unsuspecting user into
downloading a compromised resource with valid entries in the backend system.

We mitigate this threat by leveraging JavaScript's document-wide \emph{trusted
event}~\cite{TrustedEvents} delegation capability. Specifically, when a tab
navigation event is observed, the tab is flagged \texttt{suspicious} by default
and the determined OD is not updated (\ie it remains at its previous value). If
the user interacts with the tab (\ie a trusted click or key press event is
observed after navigation completes), the \texttt{suspicious} flag is cleared
and the OD is updated. If another tab navigation event occurs without user
interaction first (\eg a quick redirect), this process repeats recursively. If a
download is observed coming from a tab flagged \texttt{suspicious}, the user is
warned about the suspicious circumstances similarly to receiving an ``unsafe''
judgement.

While this mitigates the attack as described, it has the side effect of
potentially generating false positive warnings when 1) the user is redirected to
a legitimate website---such as a download mirroring service---that automatically
triggers a download after some amount of time when also 2) the user does not
interact with the page at all before the download begins. We argue such cases
are uncommon and the tradeoff here is worthy.

\subsection{Issuing Security Warnings: Privileging Security over Choice}

\TODO{Argue “override” using Chrome danger download warning UI is effective
using Chrome dev data}
