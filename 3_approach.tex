\section{The \SYSTEM{} Approach} \label{sec:approach}

In this section we detail the \SYSTEM{} approach: a novel defense against
receiving corrupted or compromised resources over the internet. We further
present the challenges and their solutions in designing \SYSTEM{} that
transparently mitigates resource integrity Supply Chain Attacks (SCA) without
degrading the experience of users that do not implement the \SYSTEM{} approach.

Further, though our concrete implementations relies on DNS authenticated with
DNS Security (DNSSEC), the approach itself is flexible and completely agnostic
of any single component. The implementation choice of highly-available
distributed \emph{backend}, for instance, is not restricted to the DNS network.
The approach works just as well with an authenticated Distributed Hash Table
(DHT) or some distributed authenticated key-value store (\eg Redis) as the
backend.

\PUNT{\TODO{Create the overview image or remove this sentence} \figref{overview}
illustrates the \SYSTEM{} approach.}

\PUNT{Frontend:}
\subsection{Transparency and User Apathy}

Human factors such as user apathy have stymied cryptographers for decades.
Schemes that are otherwise reasonably cryptographically solid can fail
catastrophically due to human error, confusion, or simple lack of interest. Some
users are likely to avoid using a security measure altogether if it presents
even a minor obstacle to immediate gratification~\cite{Clickthrough, PGPBad}. In
the browser, for example, can observe this empirically.

Leveraging the in-browser telemetry of Mozilla Firefox and Google Chrome to
passively observe over 25 million warning impressions in 2013, Akhawe et al.
found that users of Google Chrome clicked through a quarter of \emph{malware and
phishing warnings} and \emph{70\% of TLS warnings}~\cite{Clickthrough}. Users
also clicked through a third of Mozilla Firefox's TLS warnings and a tenth of
their malware and phishing warnings. That is to say: a significant percentage of
browser users are \emph{determined} not to be let TLS trust issues and/or the
threat of malware prevent them from receiving their desired content. Hence, we
must assume: some non-trivial number of users, similarly \emph{determined} to
transact resources over the internet, will not be burdened with the off-path
minutiae of manually calculating a checksum (if they are even familiar with the
jargon) and verifying the integrity of the resources they're downloading.

With this assumption in mind, the primary goal of \SYSTEM{} then is to side-step
the human factor altogether by providing a completely transparent and
unobtrusive fully automated method of checksum calculation and verification. We
achieve this through 1) the unique identification of individual hosted resources
and 2) a globally available mapping of unique resource identifiers to
corresponding checksums.

\SYSTEM{} can be imagined as a completely transparent security layer sitting
between the user and the resource. Immediately after a resource is downloaded,
the \SYSTEM{} layer will generate two cryptographic digests. One digest uniquely
fingerprints said resource based on its name. This is known as the
\emph{Non-Authoritative Checksum} (NAC) and is yielded from running the
cryptographic hashing function over the contents of the resource file. The
second digest uniquely fingerprints said resource based on its contents. This is
known as the \emph{Resource Identifier} (RI) and is yielded from running the
cryptographic hashing function over the resource's public path on the
distribution system.

Next, \SYSTEM{} uses the RI to retrieve an \emph{Authoritative Checksum} (AC)
from the backend. If successful, \SYSTEM{} will compare the NAC to the AC---we
refer to this as \emph{Non-Authoritative Checksum Validation} (NAC Validation).
Only in the case where they do not match will the user even realize \SYSTEM{}
exists. Otherwise, \SYSTEM{} remains completely transparent the the end user, as
demonstrated in our browser-based implementation.

\PUNT{\TODO{I want a figure here too as well!}}

\PUNT{Backend:}
\subsection{Defeating Co-Hosting, Perhaps for Free}

Funding and maintaining a single server/system to host all of your assets can be
extremely cost-effective in the short term compared to hosting two or more
discrete systems---one hosting the resource and one hosting the resource's
checksum. Unfortunately, this establishes a single point of failure: an
adversary that compromises such a system can both mutate the resource and update
the checksum to match the mutation. Hence, \emph{co-hosting} a resource and its
corresponding checksum on the same distribution system virtually negates the
effectiveness of having a checksum at all. This is widely understood in the
security community~\cite{SCA-MINT2}.

Hence, deployment of \SYSTEM{} necessitates the existence of a separate
distribution mechanism for resources and ACs. Though the concept of using some
distributed authenticated storage service to query a global mapping between RIs
and ACs sounds intuitive and straightforward, two natural concerns arise. The
first: modern fully authenticated schemes are based on PKI; who is managing
this infrastructure and can they be trusted? The second: who is funding the
establishment and maintenance of this potentially complex secondary system?

Fortunately, there exists a highly-available fully authenticated globally
distributed high performance low latency mapping service that web-facing
organizations and IT teams are already quite familiar with (and already pay
for): the Domain Name System (DNS). Adding extra resource records to a DNS zone
is essentially a costless operation, meaning any organization that already has a
DNSSEC-protected web presence can immediately deploy \SYSTEM{}.

To avoid co-hosting in our implementations, we preferred DNS to other candidate
highly-available authenticated systems for just these reasons.

\subsection{Platform Diversity}

From our evaluation, the computational overhead of running \SYSTEM{} is minimal
for most resources. Further, additional network load is negligible (cf.
\secref{evaluation}). Hence, the \SYSTEM{} approach can be incorporated into
software on most any device capable of communicating with the chosen backend.
This includes desktops, laptops, tablets, mobile devices, embedded systems, etc.

\subsection{Proof-of-Concept Implementations}

\subsubsection{\SYSTEM{} as a Google Chrome Extension}

We implemented \SYSTEM{} as a proof-of-concept Google Chrome extension that can
be configured to work with either global DNS or local DHT as its backend. Our
Chrome extension does not make any modifications to the Chrome user interface or
viewport (other than the extension icon itself). Further, downloads work exactly
the same whether \SYSTEM{} is installed or not---the extension is transparent to
end users. If a failure is experienced during NAC Validation, however, \SYSTEM{}
will alert the user to the dangerous download via the extension's icon and popup
interface.

The extension computes RIs from the full URL path of a resource. For example,
considering a web resource hosted at
\texttt{https://somesite.com/var/downloadme.txt}, our implementation would hash
\texttt{/var/downloadme.txt} to yield an RI.

Unlike the FileZilla patch implementation, the Chrome extension implementation
required a special \emph{Origin Domain (OD)} resolution step based on the Chrome
API's \texttt{DownloadItem::referrer} and the current Chrome tab's URL. The
Origin Domain is the base domain used to query the backend---in this case
DNS---and will always be the Second-Level Domain (SLD) fragment of the current
tab's URL in our implementation. For example: \texttt{somesite.com} would be the
OD for the URL \texttt{frag.something.somesite.com} and \texttt{fakesite.io}
would be the OD for the URL \texttt{git.fakesite.io}.

The OD is then appended to the Primary Label (PL), which is then appended to the
RI Sub-Label (SL). The Primary Label (PL) is a standard string used to identify
DNS records that belong to \SYSTEM{}; we used ``\_dnschk''. It will always
appear as the third-level domain following the OD in any request to backend. The
RI Sub-Label (SL) is a standard string used to identify DNS records that contain
RIs; we used ``\_ri'' in our implementation. The resulting construction,
consisting of \texttt{SL.PL.OD}, is appended to the RI calculated earlier. This
forms the subject of the query to our DNS backend, whereafter the DNS network
responds with a TXT record containing the AC or an indication that the RI does
not exist in the zone; the latter case is silently ignored.

Note: to remain in compliance with DNS protocol label limits, we split the
RI---a 64 character string---into two labels separated by a period. The final
construction sent to DNS consists of \texttt{RI1.RI2.SL.PL.OD}. This may not be
necessary given a different choice of backend.

\PUNT{\begin{algorithm}[t]
    %\floatname{algorithm}{Algorithm}
    \caption{Handling an incoming download in Chrome} \label{algo:dnschk}
    {\footnotesize
    \begin{algorithmic}[1]
    \Require The read request is over a contiguous segment of the backing
    store
    \Require $\ell, \ell' \leftarrow$ read requested length
    \Require $\aleph \leftarrow$ master secret
    \Require $n_{index} \leftarrow$ first nugget index to be read
    \State $data \leftarrow$ \emph{empty}
    \While{$\ell \neq 0$}
        \State $k_{n_{index}} \leftarrow GenKey_{nugget}(n_{index}, \aleph)$
        \State Fetch nugget keycount $n_{kc}$ from Keycount Store.
        \State Calculate indices touched by request: $f_{first}$, $f_{last}$
        \State $n_{flakedat} \leftarrow ReadFlakes(f_{first},\dots,f_{last})$
        \For{$f_{current} = f_{first}$ \textbf{to} $f_{last}$}
            \State $k_{f_{current}} \leftarrow GenKey_{flake}(k_{n_{index}},
            f_{current}, n_{kc})$
            \State $tag_{f_{current}} \leftarrow GenMac(k_{f_{current}},
            n_{flakedat}[f_{current}])$
            \State Verify $tag_{f_{current}}$ in Merkle Tree.
        \EndFor
        \LineComment{(\textbf{*}) denotes requested subset of nugget data}
        \State $data \leftarrow data + Decrypt(*n_{flakedat}, k_{n_{index}},
        n_{kc})$
        \State $\ell \leftarrow \ell - \|*n_{flakedat}\|$
        \State $n_{index} \leftarrow n_{index} + 1$
    \EndWhile
    \\\Return $data$ \Comment{Fulfill the read request}
    \Ensure $\|data\| <= \ell'$
    \Ensure $\ell = 0$
    \vskip -1.5em
    \end{algorithmic}
    }
\end{algorithm}}

\subsubsection{\SYSTEM{} as a FileZilla Source Patch}

We implemented \SYSTEM{} as a proof-of-concept patch to the FileZilla source.
Our does not make any modifications to FileZilla's user interface. As with the
Chrome extension, FTP downloads work exactly the same whether a user is using a
patched or non-patched version of FileZilla. The extension is similarly
transparent to end users. If a failure is experienced during NAC Validation,
\SYSTEM{} will alert the user via a popup alert.

The extension computes RIs from the full URI path of a resource on the server
(including root). For example, considering a resource hosted on an FTP server at
\texttt{/~user/var/downloadme.txt}, our implementation would hash
\texttt{/~user/var/downloadme.txt} to yield an RI.

Unlike the Chrome extension patch implementation, the FileZilla patch required
no special \emph{Origin Domain (OD)} resolution step. The domain to be used for
backend queries is the domain of the FTP server itself. The remainder of the
implementation comports with the Chrome extension implementation of \SYSTEM{}.
