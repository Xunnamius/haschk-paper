\section{Discussion} \label{sec:discussion}

In this section, we discuss some limitations of our implementations.

\subsection{DNS-Specific Protocol Limitations}

Clearly, \DNSSYS{} relies on DNS. However, DNS~\cite{DNS1} was not originally
designed to transport or store relatively large amounts of data, though this has
been addressed with EDNS0~\cite{EDNS}. The checksums stored in DNS should not be
much longer than 128 bytes or the output of the SHA512 function. Regardless, DNS
resource record extensions exist that store much more than 128 bytes of
data~\cite{CERT, IPSECKEY, DANE3, DANE1}.

Several working groups are considering DNS as a storage medium for
checksums/hash output as well, such as securitytxt~\cite{draft-sectxt}. A widely
deployed example of DNS ``TXT'' resource records being used this way is SPF and
DKIM~\cite{DKIM}. We are unaware of any practical limitation on the number of
resource records a DNS zone file can support~\cite{DNS1}, hence any
considerations regarding zone file size and/or ceilings on the number of TXT
records in a single zone are at the sole discretion of the implementing entity.

Additionally, \DNSSYS{} does not add to the danger of amplification and other
reflection attacks on DNS; these are generic DNS issues addressable at other
layers of the protocol.

\TODO{Talk a bit about how DNS is not authenticated but no one cares because of
key pinning/CAs and about how DNSSEC sucks (but we initially considered it)}

\subsection{DHT-Specific Limitations}

Unlike DNS, an entity seeking to leverage a Distributed Hash Table (DHT) may not
have the benefit of being able to rely on a high availability distributed
backend that is already established, is well-tested, and exists
globally like DNS. Such an entity would have to either maintain their own
network of DHT nodes, which can incur significant cost if such a network was not
already deployed, or piggy back off an open authenticated network, as was done
with the case with our \DHTSYS{} implementation.

These reasons make DNS more appealing for general download protection using our
approach, though software that already relies on DHTs can deploy our approach
leveraging existing systems. Regardless, we provide \DHTSYS{} to demonstrate the
utility and flexibility of the \SYSTEM{} approach.

\subsection{Limitations of Any Chrome Extension}

Our current JavaScript implementations, as Chrome extensions, are not allowed to
touch the resource files downloaded by Chrome and so cannot prevent a
potentially-malicious resource from being executed by the end user---a feature
Chrome/Chromium reserves for its own internal use. The Chrome \textit{app}
API~\cite{AppAPI} might have been of assistance as it allowed for some limited
filesystem traversal via a now deprecated native app API; there is also a
non-standard HTML5/WebExtensions FileSystem API that would provide similar
functionality were it to be widely considered~\cite{deadSpec}.

While still effective, \DNSSYS{} and \DHTSYS{} would be even more effective as
browser extensions if Chrome/Chromium or the WebExtensions API allowed for an
explicit \texttt{onComplete} event hook in the downloads API. This hook would
fire immediately before a file download completed and the file became
executable, \ie had its \texttt{.crdownload} or \texttt{.download} extension
removed. The hook would consume a \texttt{Promise}/\texttt{AsyncFunction} that
kept the download in its non-complete state until said \texttt{Promise}
completed. This would allow the extensions' background pages to do something
like alter a download's \texttt{DangerType} property and alert the end user to a
dangerous download naturally. These modifications would have the advantage of
communicating intent through the browser's familiar UI and preventing the
potentially-malicious download from becoming immediately executable.
Unfortunately, the closest the Chrome/WebExtensions API comes to allowing
\texttt{DangerType} mutations is the \texttt{acceptDanger} method on the
downloads API, but it is not suitable for use with \DNSSYS{} as a background
page based extension.

While nice to have, we stress that none of the aforesaid functionality is
critical to the ability of our implementations to more effectively mitigate SCA
risk than checksums and other solutions (cf. \secref{evaluation}).
